# -*- coding: utf-8 -*-
"""Q3 AI.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1e8Wv08OipaeLSuJj_U7qSSAOu6_K6u2Y
"""

from operator import itemgetter
import operator


# Differences between two lists
def diff(li1, li2):
    li_dif = [i for i in li1 + li2 if i not in li1 or i not in li2]
    return li_dif


# Get allowed colors for a city
def get_allowed_colors(graph, city, colors):
    not_allowed_colors = [city[1] for city in graph[(city, False)] if city[1] is not ''] # ' ' means no color assigned. Otherwise, There will be a value like Red, Green or Blue
    allowed_colors = diff(colors, not_allowed_colors) # allowed_colors = total colors - assigned colors
    return allowed_colors


# MCV.
# return index of city or cities with maximum neighbours.
def mcv(graph):

    num_of_neighbours = [(index, len(l[1])) for index, l in enumerate(graph.items()) if l[0][1] is False] # converts the graph into a list of the form [index, no of neighbours]. eg: [0,3], where 0 means Balochistan which has 3 neighbours
    max_neighbour = max(num_of_neighbours, key=itemgetter(1))[1] # gets the max neighbours from the num_of_neighbours list 
    max_num_of_neighbours = [t[0] for t in num_of_neighbours if t[1] == max_neighbour] # gets the correspoding index/indexes which has maximum no of neighbours 
    cities = [list(graph)[index][0] for index in max_num_of_neighbours] # gets the city/cities corresponding to that index/indexes
  
    return cities


# MRV.
# return city or cities with minimum remaining values/colors
def mrv(graph, colors):
    cities_without_color = [(city[0]) for city, colored in graph.items() if city[1] is False] # creates a list of cities that have not been assigned a color
    allowed_color_each_city = {} # creates an empty dictionary
    for city in cities_without_color:
        allowed_color_each_city[city] = get_allowed_colors(graph, city, colors) # gets the allowed colors for the unassigned city

    min_available_color_len = min([len(allowed_colors) for city, allowed_colors in allowed_color_each_city.items()]) # gets the minimum colors available from the allowed_color dictionary
    cities = [city for city, colors in allowed_color_each_city.items() if len(colors) is min_available_color_len] # gets the corresponding city/cities with num_colors = min_available_color
    return cities

# Color selected city
def coloring(graph, city, color):

    neighbours = graph[(city, False)] # indexes the graph to retrives the values(i.e. neighbours) corresponding to the key (city, False)
    del graph[(city, False)] # deletes the entry for the city which is to be assigned color 
    graph[(city, True)] = neighbours # assigns the color to city( i.e (city, True) ) and appends to the end of the graph

    for nei_list in graph.values(): # iterates over all neighbours for each city

        for n in nei_list: 
            if n[0] == city: # if any city has neighbour = city (which is to be assigned color)
                l = list(n) 
                l[1] = color # assigns the color to that city
                t = tuple(l)
                nei_list.remove(n) # removes the old unassinged entry
                nei_list.append(t) # adds the new assigned entry

def build_graph(map):
    # key: (X, Bool). X means city AND Bool means Colored Or Not
    # value: [(X, ''), (Y, '')]. List of neighbours. Second item of tuple is color of city
    graph = {}

    for city in map:
        neighbours = map[city]

        # Converting format of neighbours. [X, Y] => [('X', ''), ('Y', '')]
        neighbours = [(neighbour, '') for neighbour in neighbours if neighbour != '']
        graph[(city, False)] = neighbours

    return graph

import sys
from pprint import pprint

map = { 'B':['S','NWFP','P'] , 'S': ['B','P'] , 'P': ['NWFP', 'B', 'S', 'K'] , 'NWFP': ['B', 'P', 'K'] , 'K': ['NWFP', 'P'] }

colors = ['RED', 'GREEN', 'BLUE']

# Build graph of given map
graph = build_graph(map)

print("Initial Map: ")
print(graph, "\n\n")


for i in range(len(graph)):
    cities_with_max_degree = mcv(graph)
    cities_with_minimum_remaining_colors = mrv(graph, colors)

    selected_city = set(cities_with_max_degree).intersection(set(cities_with_minimum_remaining_colors)).pop() # choose the city according to mcv & mrv

    # Get allowed color for selected city
    allowed_colors = set( get_allowed_colors(graph, selected_city, colors) ) 

    color = allowed_colors.pop()  

    coloring(graph, selected_city, color) # color the city


alone_cities = [graph[city].append("Any Color") for city, neighbours in graph.items() if len(neighbours) == 0] # assign "Any color" to cities that have 0 neighbours

print("Colored Map:")
pprint(graph)

