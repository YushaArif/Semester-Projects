# -*- coding: utf-8 -*-
"""Q1 AI.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UbrFHNvf84L8SaLC4s85JsU7R74H_Omu
"""

import numpy

def calculate_fitness(input_weights, pop):
    # Calculating the fitness value of each solution in the current population.
    # The fitness function caulcuates the sum of products between each input and its corresponding weight.
    fitness = numpy.sum(pop*input_weights, axis=1)
    return fitness

def select_mating_pool(pop, fitness, num_parents):
    # Selecting the best individuals in the current generation as parents for producing the offspring of the next generation.
    parents = numpy.empty((num_parents, pop.shape[1]))
    for parent_num in range(num_parents):
        max_fitness_idx = numpy.where(fitness == numpy.max(fitness))
        max_fitness_idx = max_fitness_idx[0][0]
        parents[parent_num, :] = pop[max_fitness_idx, :]
        fitness[max_fitness_idx] = -99999999999
    return parents

def crossover(parents, offspring_size):
    offspring = numpy.empty(offspring_size)
    # Using single point crossover, this is the point at which crossover takes place between two parents. For simplicity, its taken as the center
    crossover_point = numpy.uint8(offspring_size[1]/2)

    for k in range(offspring_size[0]):
        # Index of the first parent to mate.
        parent1_idx = k%parents.shape[0]
        # Index of the second parent to mate.
        parent2_idx = (k+1)%parents.shape[0]
        # The new offspring will have its first half of its genes taken from the first parent.
        offspring[k, 0:crossover_point] = parents[parent1_idx, 0:crossover_point]
        # The new offspring will have its second half of its genes taken from the second parent.
        offspring[k, crossover_point:] = parents[parent2_idx, crossover_point:]
    return offspring

def mutation(offspring_crossover, len):
    # Mutation changes a single gene in each offspring randomly .
    for idx in range(offspring_crossover.shape[0]):
        # The random bit will be chosen and will be set to 1. len describes the length of the chromosome.
        random_index = numpy.random.choice(len)
        offspring_crossover[idx][random_index] = 1
    return offspring_crossover

import numpy
import matplotlib.pyplot as plt
import math
from pprint import pprint

# weights for each bit in a chromosome.
input_weights = [1,2,4,8,16,32,64,128,256,1024,2048,4096]

# length of the chromosome. Has length equal to the size of input_weights array
chrom_len = 12

sol_per_pop = 4 
num_parents_mating = 2

# Defining the population size.
pop_size = (sol_per_pop,chrom_len) # The population will have sol_per_pop chromosomes where each chromosome has chrom_len genes.
#Creating the initial population.
arr = [0,1]
new_population = numpy.random.choice(arr,pop_size,p = [0.7,0.3])
print("Initial Population: ")
print(new_population)

""" variables for plotting the result of no of generation(x_axis) vs fitness value (y_axis) """

x_gen = []  
y_fitness = []
ideal_sol = [numpy.sum(input_weights) for i in range(2,10)] # this array will be used to compare the ideal fitness with the calculated fitness

for gen in range(2,10): # no of generations: Min = 2 ; Max = 10
  
  print("*************** NO OF GENERATIONS: ", gen, "***************")
  num_generations = gen
  for generation in range(num_generations):
    print("Generation : ", generation)
    # Measing the fitness of each chromosome in the population.
    fitness = calculate_fitness(input_weights, new_population)

    # Selecting the best parents in the population for mating.
    parents = select_mating_pool(new_population, fitness, num_parents_mating)

    # Generating next generation using crossover.
    offspring_crossover = crossover(parents, offspring_size=(pop_size[0]-parents.shape[0], chrom_len))

    # Adding some variations to the offsrping using mutation.
    offspring_mutation = mutation(offspring_crossover, chrom_len)

    # Creating the new population based on the parents and offspring.
    new_population[0:parents.shape[0], :] = parents # half of the chromosomes of parents are retained in case the offsprings turn out to be unfit 
    new_population[parents.shape[0]:, :] = offspring_mutation # the remaining half consists of chromosomes formed from the offsprings

    # The best result in the current iteration.
    print("Best result : ", numpy.max(numpy.sum(new_population*input_weights, axis=1)))

  # Getting the best solution after iterating finishing all generations.
  #At first, the fitness is calculated for each solution in the final generation.
  fitness = calculate_fitness(input_weights, new_population)
  # Then return the index of that solution corresponding to the best fitness.
  best_match_idx = numpy.where(fitness == numpy.max(fitness))

  # adding the no of generation used and corresponding fitness found.
  x_gen.append(gen)
  y_fitness.append(fitness[best_match_idx][0])
  print("Best solution fitness : ", fitness[best_match_idx][0])

# plotting the results 
plt.plot(x_gen,ideal_sol, color = 'red', label = 'ideal fitness')
plt.plot(x_gen,y_fitness, color = 'blue', label = 'chromosome fitness')
plt.xlabel('no of generations')
plt.ylabel('fitness value')
plt.legend()
plt.show

import numpy
import matplotlib.pyplot as plt
import math


""" variables for plotting the result of chromosome length(x_axis) vs fitness value (y_axis) """
x_chromLen = []
y_fitness = []
ideal_sol = [] 

for i in range(4,16): # chromosome length : Min = 4 ; Max = 16
  # Inputs of the equation.
  input_weights = [] 

  # Setting the chromosome length.
  chrom_len = i 

  print("*************** NO OF CHROMOSOMES: ", chrom_len, "***************")

  for j in range(i):
    input_weights.append(pow(2,j)) # initializing the input_weights array with values 2^0 2^1 2^2 .... 2^i
    
  #fixing the solutions per population and number of parents used for mating  
  sol_per_pop = 4 
  num_parents_mating = 2

  # Defining the population size.
  pop_size = (sol_per_pop,chrom_len) # The population will have sol_per_pop chromosome where each chromosome has chrom_len genes.
  #Creating the initial population.
  arr = [0,1]
  new_population = numpy.random.choice(arr,pop_size,p = [0.7,0.3])
  print("Initial Population: ")
  print(new_population)
  
  num_generations = 4 # fixing the no of generations 

  for generation in range(num_generations):
    print("Generation : ", generation)
    
    # Measing the fitness of each chromosome in the population.
    fitness = calculate_fitness(input_weights, new_population)

    # Selecting the best parents in the population for mating.
    parents = select_mating_pool(new_population, fitness, num_parents_mating)

    # Generating next generation using crossover.
    offspring_crossover = crossover(parents, offspring_size=(pop_size[0]-parents.shape[0], chrom_len))

    # Adding some variations to the offsrping using mutation.
    offspring_mutation = mutation(offspring_crossover, chrom_len)

    # Creating the new population based on the parents and offspring.
    new_population[0:parents.shape[0], :] = parents
    new_population[parents.shape[0]:, :] = offspring_mutation

    # The best result in the current iteration.
    print("Best result : ", numpy.max(numpy.sum(new_population*input_weights, axis=1)))

  # Getting the best solution after iterating finishing all generations.
  #At first, the fitness is calculated for each solution in the final generation.
  fitness = calculate_fitness(input_weights, new_population)
  # Then return the index of that solution corresponding to the best fitness.
  best_match_idx = numpy.where(fitness == numpy.max(fitness))
  print("Best solution fitness : ", fitness[best_match_idx][0])

  # adding the length of chromosome used and the fitness value found
  x_chromLen.append(i)
  y_fitness.append(fitness[best_match_idx][0])
  ideal_sol.append(numpy.sum(input_weights)) # adding the ideal fitness value for the given chromosome length


#plotting the results
plt.plot(x_chromLen,ideal_sol, color = 'red', label = 'ideal fitness')
plt.plot(x_chromLen,y_fitness, color = 'blue', label = 'chromosome fitness')
plt.xlabel('chromosome length')
plt.ylabel('fitness value')
plt.legend()
plt.show

import numpy
import matplotlib.pyplot as plt
import math

# weights for each bit in a chromosome.
input_weights = [1,2,4,8,16,32,64,128,256,1024,2048,4096, 8192, 16384]

#initializing the chromosome length.
chrom_len = 14

""" variables for plotting population size(x_axis) vs fitness value(y_axis) """
x_popSize = []
y_fitness = []
ideal_sol = [numpy.sum(input_weights) for i in range(4,20)]

for i in range(4,20): #population size: Min 4 ; Max: 20

  sol_per_pop = i
  num_parents_mating = 2

  print("*************** POPULATION SIZE: ", i, "***************")

  # Defining the population size.
  pop_size = (sol_per_pop,chrom_len) # The population will have sol_per_pop chromosome where each chromosome has chrom_len genes.
  #Creating the initial population.
  arr = [0,1]
  new_population = numpy.random.choice(arr,pop_size,p = [0.7,0.3])
  print("Initial Population: ")
  print(new_population)
  
  num_generations = 4 #fixing the no of generations 

  for generation in range(num_generations):
    print("Generation : ", generation)
    # Measing the fitness of each chromosome in the population.
    fitness = calculate_fitness(input_weights, new_population)

    # Selecting the best parents in the population for mating.
    parents = select_mating_pool(new_population, fitness, num_parents_mating)

    # Generating next generation using crossover.
    offspring_crossover = crossover(parents,offspring_size=(pop_size[0]-parents.shape[0], chrom_len))

    # Adding some variations to the offsrping using mutation.
    offspring_mutation = mutation(offspring_crossover, chrom_len)

    # Creating the new population based on the parents and offspring.
    new_population[0:parents.shape[0], :] = parents
    new_population[parents.shape[0]:, :] = offspring_mutation

    # The best result in the current iteration.
    print("Best result : ", numpy.max(numpy.sum(new_population*input_weights, axis=1)))

  # Getting the best solution after iterating finishing all generations.
  #At first, the fitness is calculated for each solution in the final generation.
  fitness = calculate_fitness(input_weights, new_population)
  # Then return the index of that solution corresponding to the best fitness.
  best_match_idx = numpy.where(fitness == numpy.max(fitness))

  # adding the size of population used and the fitness value found 
  x_popSize.append(i)
  y_fitness.append(fitness[best_match_idx][0])
  #print("Best solution : ", new_population[best_match_idx, :])
  print("Best solution fitness : ", fitness[best_match_idx][0])

#plotting the results
plt.plot(x_popSize,ideal_sol, color = 'red', label = 'ideal fitness')
plt.plot(x_popSize,y_fitness, color = 'blue', label = 'chromosome fitness')
plt.xlabel('population size')
plt.ylabel('fitness value')
plt.legend()
plt.show

